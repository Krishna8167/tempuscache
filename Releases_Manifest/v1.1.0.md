# ğŸ·ï¸ v1.0.0 â€” In-Memory TTL Cache with Concurrency & Background Eviction

## ğŸš€ Overview

<img width="883" height="762" alt="Screenshot 2026-01-20 161020" src="https://github.com/user-attachments/assets/ca90f566-4dd8-41cb-ac2c-9e7817030db0" />


Weâ€™re excited to release **v1.0.0** â€” the first stable version of our in-memory caching layer designed for **performance**, **predictability**, and **safety** in concurrent Go applications.

This release introduces a **thread-safe TTL (Time-To-Live) cache** with a **hybrid eviction strategy** that ensures efficient memory usage and reliable expiration semantics.

---

## ğŸ§  Whatâ€™s Included

### âœ”ï¸ In-Memory Cache with TTL

A simple and efficient cache implementation backed by:

```go
map[string]Item

Each cached **Item** contains:

- **Value** â€” the cached data (any type)
- **ExpiryTime** â€” the exact timestamp when the item expires

All cache entries share a **common TTL duration** defined during cache initialization.

---

## ğŸ” Thread Safety with `sync.RWMutex`

The cache is fully safe for concurrent access:

### Read Operations (`Get`)
- Allow multiple concurrent readers
- Optimized for high-read workloads

### Write/Delete Operations (`Set`, eviction)
- Use exclusive locking
- Prevent race conditions during mutation

This makes the cache suitable for:

- Web servers
- Background workers
- Asynchronous pipelines
- Concurrent services

---

## â±ï¸ Expiration & Eviction Logic

To maintain cache health and correctness, the cache uses a **hybrid expiration strategy**.

### ğŸŸ¡ Lazy Expiration
- Every `Get` checks the itemâ€™s expiration time
- If expired:
  - The key is deleted immediately
  - The operation is treated as a cache miss

### ğŸ”µ Active Background Eviction
- A background goroutine periodically scans the cache
- Removes expired entries at a fixed interval
- Prevents stale data from accumulating when keys are not accessed

This approach ensures correctness **without blocking primary cache operations**.

---

## ğŸ“¦ Usage Example

```go
cache := NewCache(5 * time.Second)
cache.startEviction(2 * time.Second)

cache.Set("name", "krishna")

time.Sleep(6 * time.Second)

if _, ok := cache.Get("name"); !ok {
    fmt.Println("Expired (Cleaned by eviction workflow)")
}

```
## ğŸ› ï¸ Highlights

- â³ Predictable TTL-based expiration
- ğŸ” Thread-safe read and write operations
- ğŸ§© Simple and clean API for easy integration
- ğŸ§¹ Background eviction keeps memory usage in check

---

## ğŸ Summary

**v1.0.0** lays a solid foundation for a reliable in-memory caching solution in Go.

